<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>plugins</title>
        <link rel="stylesheet" href="style.css" />
        <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      div.columns{display: flex; gap: min(4vw, 1.5em);}
      div.column{flex: auto; overflow-x: auto;}
      div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
      /* The extra [class] is a hack that increases specificity enough to
         override a similar rule in reveal.js */
      ul.task-list[class]{list-style: none;}
      ul.task-list li input[type="checkbox"] {
        font-size: inherit;
        width: 0.8em;
        margin: 0 0.8em 0.2em -1.6em;
        vertical-align: middle;
      }
      .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    </style>
  </head>
  <body>
    <nav>
      <a href="index.html">Home</a>
      <a href="packages.html">Packages</a>
      <a href="directives.html">Directives</a>
      <a href="macros.html">Macros</a>
      <a href="include.html">Include</a>
      <a href="import.html">Import</a>
      <a href="fstrings.html">F-strings</a>
      <a href="const.html">Const</a>
      <a href="deconstruct.html">Deconstruct</a>
      <a href="preflight.html">Preflight</a>
      <a href="plugins.html">Plugins</a>
      <a href="tests.html">Tests</a>
    </nav>
    <main><h1 id="plugins">Plugins</h1>
<p>Builder supports plugins to extend processing. Plugins are R packages
that export a function returning a list of lifecycle methods.</p>
<h2 id="usage">Usage</h2>
<p>Specify plugins with the <code>-plugin</code> flag:</p>
<pre><code>./builder -input srcr -plugin package::function</code></pre>
<p>The format is <code>package::function</code> where
<code>package</code> is the R package name and <code>function</code> is
the exported function that creates the plugin.</p>
<h2 id="lifecycle-methods">Lifecycle Methods</h2>
<p>Plugins can implement the following methods:</p>
<h3 id="setupinput-output">setup(input, output)</h3>
<p>Called during initialization with the input and output directory
paths. Use this to store configuration or perform one-time setup.</p>
<h3 id="preprocessstr-file">preprocess(str, file)</h3>
<p>Called on each file’s content before Builder processes it. Receives
the file content as a string and should return the modified content.</p>
<h3 id="postprocessstr-file">postprocess(str, file)</h3>
<p>Called on each file’s content before Builder processes it. Receives
the file content as a string and should return the modified content.</p>
<h3 id="end">end()</h3>
<p>Called when Builder finishes processing all files. Use this for
cleanup or final operations.</p>
<h2 id="example-plugin">Example Plugin</h2>
<p>A simple minifier plugin that replaces newlines with semicolons:</p>
<pre><code>#&#39; @export
plugin &lt;- function() {
  list(
    setup = function(input, output, ...) {},
    preprocess = function(str, file, ...) {
      lines &lt;- strsplit(str, &quot;\n&quot;)[[1]]
      lines &lt;- lines[nzchar(trimws(lines))]
      paste(lines, collapse = &quot;;&quot;)
    },
    postprocess = function(str, file, ...) {},
    end = function(...) {}
  )
}</code></pre>
<p>Use it with <code>-plugin minifier::plugin</code>. Methods that don’t
need to modify content can return <code>NULL</code> or be empty. Use
<code>...</code> in function signatures for forward
compatibility.</p></main>
  </body>
</html>
